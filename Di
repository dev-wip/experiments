/* stm32mp157f-custom-display.dtsi */

/* =====================================================================
 * PIN CONTROL
 * ===================================================================== */
&pinctrl {
	ltdc_pins_a: ltdc-0 {
		pins {
			pinmux = <STM32_PINMUX('J', 12, AF14)>, /* B0 */
				 <STM32_PINMUX('J', 13, AF14)>, /* B1 */
				 <STM32_PINMUX('J', 14, AF14)>, /* B2 */
				 <STM32_PINMUX('J', 15, AF14)>, /* B3 */
				 <STM32_PINMUX('K', 3, AF14)>,  /* B4 */
				 <STM32_PINMUX('K', 4, AF14)>,  /* B5 */
				 <STM32_PINMUX('K', 5, AF14)>,  /* B6 */
				 <STM32_PINMUX('K', 6, AF14)>,  /* B7 */
				 <STM32_PINMUX('J', 7, AF14)>,  /* G0 */
				 <STM32_PINMUX('J', 8, AF14)>,  /* G1 */
				 <STM32_PINMUX('J', 9, AF14)>,  /* G2 */
				 <STM32_PINMUX('J', 10, AF14)>, /* G3 */
				 <STM32_PINMUX('J', 11, AF14)>, /* G4 */
				 <STM32_PINMUX('K', 0, AF14)>,  /* G5 */
				 <STM32_PINMUX('K', 1, AF14)>,  /* G6 */
				 <STM32_PINMUX('K', 2, AF14)>,  /* G7 */
				 <STM32_PINMUX('I', 15, AF14)>, /* R0 */
				 <STM32_PINMUX('J', 0, AF14)>,  /* R1 */
				 <STM32_PINMUX('J', 1, AF14)>,  /* R2 */
				 <STM32_PINMUX('J', 2, AF14)>,  /* R3 */
				 <STM32_PINMUX('J', 3, AF14)>,  /* R4 */
				 <STM32_PINMUX('J', 4, AF14)>,  /* R5 */
				 <STM32_PINMUX('J', 5, AF14)>,  /* R6 */
				 <STM32_PINMUX('J', 6, AF14)>,  /* R7 */
				 <STM32_PINMUX('I', 14, AF14)>, /* CLK */
				 <STM32_PINMUX('K', 7, AF14)>,  /* DE */
				 <STM32_PINMUX('I', 12, AF14)>, /* HSYNC */
				 <STM32_PINMUX('I', 13, AF14)>; /* VSYNC */
			bias-disable;
			drive-push-pull;
			slew-rate = <3>;
		};
	};

	cec_pins_a: cec-0 {
		pins {
			pinmux = <STM32_PINMUX('A', 6, AF5)>;
			bias-disable;
			drive-open-drain;
			slew-rate = <0>;
		};
	};

	i2c2_pins_a: i2c2-0 {
		pins {
			pinmux = <STM32_PINMUX('H', 4, AF4)>, /* SCL */
				 <STM32_PINMUX('H', 5, AF4)>; /* SDA */
			bias-disable;
			drive-open-drain;
			slew-rate = <0>;
		};
	};
};

/* =====================================================================
 * DEVICES
 * ===================================================================== */
/ {
	/* HDMI Bridge (TI TFP410) */
	tfp410_bridge: tfp410-bridge {
		compatible = "ti,tfp410";
		#address-cells = <1>;
		#size-cells = <0>;
		
		/* Power Down (PI10) - Controlled by Driver */
		powerdown-gpios = <&gpioi 10 GPIO_ACTIVE_LOW>;
		
		/* DDC Bus for EDID */
		ddc-i2c-bus = <&i2c2>;

		ports {
			#address-cells = <1>;
			#size-cells = <0>;

			port@0 {
				reg = <0>;
				tfp410_in: endpoint {
					remote-endpoint = <&ltdc_ep0>;
				};
			};

			port@1 {
				reg = <1>;
				tfp410_out: endpoint {
					remote-endpoint = <&hdmi_con>;
				};
			};
		};
	};

	/* HDMI Connector */
	hdmi-connector {
		compatible = "hdmi-connector";
		type = "a";
		ddc-i2c-bus = <&i2c2>;

		port {
			hdmi_con: endpoint {
				remote-endpoint = <&tfp410_out>;
			};
		};
	};
};

/* LTDC */
&ltdc {
	pinctrl-names = "default";
	pinctrl-0 = <&ltdc_pins_a>;
	status = "okay";

	port {
		ltdc_ep0: endpoint@0 {
			reg = <0>;
			remote-endpoint = <&tfp410_in>;
		};
	};
};

/* HDMI CEC */
&cec {
	pinctrl-names = "default";
	pinctrl-0 = <&cec_pins_a>;
	clocks = <&rcc CEC_K>;    /* Requires TF-A change below */
	clock-names = "cec";
	status = "okay";
};

/* I2C2 (DDC) */
&i2c2 {
	pinctrl-names = "default";
	pinctrl-0 = <&i2c2_pins_a>;
	i2c-scl-rising-time-ns = <185>;
	i2c-scl-falling-time-ns = <20>;
	status = "okay";
};

/* GPIO Hog for HDMI Reset (PA10) 
 * Required because the TFP410 driver doesn't handle reset pins, 
 * and the chip must be awake for Linux to probe it.
 */
&gpioa {
	tfp410_reset_hog {
		gpio-hog;
		gpios = <10 GPIO_ACTIVE_HIGH>;
		output-high;
		line-name = "tfp410-reset";
	};
};
